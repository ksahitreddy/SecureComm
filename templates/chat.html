{% extends "base.html" %}

{% block title %}Chat with {{ recipient }} - Secure Chat{% endblock %}

{% block content %}
<style>
    body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
        background-size: 400% 400%;
        animation: gradientShift 15s ease infinite;
        min-height: 100vh;
        overflow-x: hidden;
    }

    @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* Floating particles */
    .chat-particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .particle {
        position: absolute;
        width: 4px;
        height: 4px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        animation: float 20s infinite linear;
    }

    .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { left: 20%; animation-delay: 2s; }
    .particle:nth-child(3) { left: 30%; animation-delay: 4s; }
    .particle:nth-child(4) { left: 40%; animation-delay: 6s; }
    .particle:nth-child(5) { left: 50%; animation-delay: 8s; }
    .particle:nth-child(6) { left: 60%; animation-delay: 10s; }
    .particle:nth-child(7) { left: 70%; animation-delay: 12s; }
    .particle:nth-child(8) { left: 80%; animation-delay: 14s; }
    .particle:nth-child(9) { left: 90%; animation-delay: 16s; }

    @keyframes float {
        0% {
            transform: translateY(100vh) rotate(0deg);
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            transform: translateY(-100px) rotate(360deg);
            opacity: 0;
        }
    }

    /* Glass morphism containers */
    .glass-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        position: relative;
        z-index: 10;
    }

    .chat-header {
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px 20px 0 0;
        padding: 20px;
    }

    .chat-container {
        height: 60vh;
        overflow-y: auto;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        position: relative;
    }

    .chat-footer {
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0 0 20px 20px;
        padding: 20px;
    }

    /* Message bubbles */
    .message-bubble {
        max-width: 70%;
        margin: 10px 0;
        padding: 12px 16px;
        border-radius: 18px;
        position: relative;
        backdrop-filter: blur(10px);
        animation: messageSlideIn 0.3s ease-out;
    }

    @keyframes messageSlideIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .message-sent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
        border-bottom-right-radius: 4px;
    }

    .message-received {
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        margin-right: auto;
        border-bottom-left-radius: 4px;
    }

    .message-ai {
        background: linear-gradient(135deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
        color: white;
        margin-right: auto;
        border-bottom-left-radius: 4px;
        border: 1px solid rgba(139, 92, 246, 0.3);
    }

    .message-timestamp {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-top: 4px;
    }

    /* Input styling */
    .message-input-container {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 25px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        overflow: hidden;
        backdrop-filter: blur(10px);
    }

    .message-input {
        border: none;
        background: transparent;
        padding: 12px 20px;
        resize: none;
        outline: none;
        color: #333;
        font-size: 14px;
    }

    .message-input::placeholder {
        color: #666;
        opacity: 0.8;
    }

    .message-input:focus {
        outline: none;
        box-shadow: none;
    }

    .send-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.3s ease;
        margin: 5px;
    }

    .send-button:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .attach-button {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        transition: all 0.3s ease;
        margin: 7px;
    }

    .attach-button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
    }

    /* User avatar */
    .user-avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 18px;
        margin-right: 15px;
    }

    /* Online indicator */
    .online-indicator {
        width: 12px;
        height: 12px;
        background: #10B981;
        border-radius: 50%;
        position: absolute;
        bottom: 2px;
        right: 2px;
        border: 2px solid white;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
        100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
    }

    /* Buttons */
    .glass-button {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        color: white;
        padding: 8px 16px;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .glass-button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        color: white;
    }

    .back-button {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.3s ease;
        text-decoration: none;
    }

    .back-button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateX(-3px);
        color: white;
    }

    /* Scrollbar styling */
    .chat-container::-webkit-scrollbar {
        width: 6px;
    }

    .chat-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
    }

    .chat-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
    }

    /* Typing indicator */
    .typing-indicator {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 18px;
        margin: 10px 0;
        max-width: 70%;
        animation: messageSlideIn 0.3s ease-out;
    }

    .typing-dots {
        display: flex;
        gap: 4px;
    }

    .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #666;
        animation: typingBounce 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }

    @keyframes typingBounce {
        0%, 80%, 100% {
            transform: scale(0);
        }
        40% {
            transform: scale(1);
        }
    }

    /* Input styling */
    .message-input-container {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 25px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        overflow: hidden;
        backdrop-filter: blur(10px);
    }

    .message-input {
        border: none;
        background: transparent;
        padding: 12px 20px;
        resize: none;
        outline: none;
        color: #333;
        font-size: 14px;
    }

    /* Security badge */
    .security-badge {
        background: rgba(16, 185, 129, 0.2);
        color: #10B981;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.75rem;
        border: 1px solid rgba(16, 185, 129, 0.3);
    }

    /* Online users sidebar */
    .online-users-list {
        max-height: 350px;
        overflow-y: auto;
    }
    
    .online-user-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 6px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        color: white;
    }
    
    .online-user-item:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
        transform: translateY(-1px);
        color: white;
    }
    
    .online-user-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 14px;
        margin-right: 10px;
        position: relative;
    }
    
    .online-user-avatar::after {
        content: '';
        position: absolute;
        bottom: -2px;
        right: -2px;
        width: 10px;
        height: 10px;
        background: #10b981;
        border: 2px solid rgba(0, 0, 0, 0.8);
        border-radius: 50%;
    }
    
    .online-user-name {
        font-size: 14px;
        font-weight: 500;
        flex: 1;
    }
    
    .online-users-list::-webkit-scrollbar {
        width: 4px;
    }
    
    .online-users-list::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
    }
    
    .online-users-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
    }

    /* Chat Layout Container - WhatsApp Web Style */
    .chat-layout-container {
        display: flex;
        height: calc(100vh - 100px);
        width: 100%;
        padding: 20px;
        gap: 15px;
    }
    
    .chat-main-section {
        flex: 0 0 85%;
        width: 85%;
        display: flex;
        flex-direction: column;
    }
    
    .chat-sidebar-section {
        flex: 0 0 15%;
        width: 15%;
        display: flex;
        flex-direction: column;
    }
    
    .chat-main-section .glass-container,
    .chat-sidebar-section .glass-container {
        height: 100%;
        display: flex;
        flex-direction: column;
    }
    
    /* Mobile responsive */
    @media (max-width: 991px) {
        .chat-layout-container {
            flex-direction: column;
            height: auto;
        }
        
        .chat-main-section {
            flex: 1;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .chat-sidebar-section {
            display: none; /* Hide sidebar on mobile */
        }
    }

    /* Responsive design */
    @media (max-width: 768px) {
        .glass-container {
            margin: 10px;
            border-radius: 15px;
        }
        
        .chat-container {
            height: 50vh;
        }
        
        .message-input-container {
            padding: 15px;
        }
        
        .message-bubble {
            max-width: 85%;
        }
    }
</style>

<!-- Floating particles -->
<div class="chat-particles">
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
</div>

<div class="chat-layout-container">
    <div class="chat-main-section">
        <div class="glass-container">
                <!-- Chat Header -->
                <div class="chat-header">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <a href="{{ url_for('dashboard') }}" class="back-button me-3">
                                <i class="fas fa-arrow-left"></i>
                            </a>
                            <div class="position-relative">
                                <div class="user-avatar">
                                    {{ recipient[0].upper() }}
                                </div>
                                {% if is_recipient_online %}
                                <div class="online-indicator"></div>
                                {% endif %}
                            </div>
                            <div>
                                <h5 class="mb-0 text-white fw-bold">{{ recipient }}</h5>
                                <small class="text-white-50">
                                    {% if is_recipient_online %}
                                        <i class="fas fa-circle text-success me-1" style="font-size: 0.5rem;"></i>Online now
                                    {% else %}
                                        <i class="fas fa-circle text-muted me-1" style="font-size: 0.5rem;"></i>Offline
                                    {% endif %}
                                </small>
                            </div>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <button class="glass-button" id="startVoiceCall" title="Voice Call">
                                <i class="fas fa-phone"></i>
                            </button>
                            <button class="glass-button" id="startVideoCall" title="Video Call">
                                <i class="fas fa-video"></i>
                            </button>
                            <div class="dropdown">
                                <button class="glass-button dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    <li><a class="dropdown-item" href="#"><i class="fas fa-search me-2"></i>Search</a></li>
                                    <li><a class="dropdown-item" href="#"><i class="fas fa-bell me-2"></i>Mute</a></li>
                                    <li><hr class="dropdown-divider"></li>
                                    <li><a class="dropdown-item text-danger" href="#" id="clearChatBtn">
                                        <i class="fas fa-trash me-2"></i>Clear Chat
                                    </a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                
                <!-- Chat Messages -->
                <div id="chat-messages" class="chat-container">
                    <div id="message-list"></div>
                    <!-- Typing indicator will be added here dynamically -->
                </div>
                
                <!-- Chat Footer -->
                <div class="chat-footer">
                    <div class="message-input-container d-flex align-items-center">
                        <input type="file" id="file-input" class="d-none" />
                        <button type="button" class="attach-button" id="attach-file-btn" title="Attach file">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <textarea id="message-input" class="message-input flex-grow-1" placeholder="Type your message..." rows="1"></textarea>
                        <button class="send-button" type="button" id="send-button" title="Send message">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                    
                    <!-- File info and progress -->
                    <div class="d-flex align-items-center justify-content-between mt-2">
                        <div class="d-flex align-items-center gap-3">
                            <span class="security-badge">
                                <i class="fas fa-shield-alt me-1"></i>End-to-End Encrypted
                            </span>
                            <small class="text-white-50">Max file size: 10MB</small>
                        </div>
                        <small id="file-info" class="text-white-50 fst-italic"></small>
                    </div>
                    
                    <div class="progress d-none mt-2" id="upload-progress-container" style="height: 4px; border-radius: 2px;">
                        <div id="upload-progress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Right sidebar - Online Users -->
    <div class="chat-sidebar-section">
        <div class="glass-container">
            <div class="p-3 h-100 d-flex flex-column">
                <div class="d-flex align-items-center mb-3">
                    <i class="fas fa-users me-2 text-success"></i>
                    <h6 class="text-white mb-0">Online Users</h6>
                    <span class="badge bg-success ms-auto" id="sidebar-online-count">0</span>
                </div>
                
                <!-- Online users list -->
                <div id="sidebar-online-users" class="online-users-list flex-grow-1">
                    <div class="text-center text-white-50 py-4" id="sidebar-no-users">
                        <i class="fas fa-user-slash fa-2x mb-2 opacity-50"></i>
                        <p class="small mb-0">No users online</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    
    <!-- Call Modal -->
    <div class="modal fade" id="callModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="callModalLabel">Incoming Call</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <img id="callerAvatar" src="" class="rounded-circle mb-3" width="100" height="100" alt="Caller">
                    <h4 id="callerName">Caller Name</h4>
                    <p id="callType" class="text-muted">Incoming Video Call</p>
                    <div class="d-flex justify-content-center gap-3 mb-3">
                        <button type="button" class="btn btn-success btn-lg rounded-circle" id="acceptCall">
                            <i class="fas fa-phone"></i>
                        </button>
                        <button type="button" class="btn btn-danger btn-lg rounded-circle" id="rejectCall">
                            <i class="fas fa-phone-slash"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Call Controls -->
    <div class="position-fixed bottom-0 end-0 m-3" id="callControls" style="display: none; z-index: 1050;">
        <div class="card shadow">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h6 class="mb-0" id="callStatus">Call in progress</h6>
                <button type="button" class="btn-close" id="minimizeCall"></button>
            </div>
            <div class="card-body p-2">
                <div class="row g-2">
                    <div class="col-12">
                        <video id="remoteVideo" autoplay playsinline style="width: 100%; max-height: 350px; background: #000; border-radius: 8px;"></video>
                        <video id="localVideo" autoplay playsinline muted style="position: absolute; bottom: 80px; right: 20px; width: 120px; height: 90px; border: 2px solid #fff; border-radius: 8px; background: #000;"></video>
                        <audio id="remoteAudio" autoplay playsinline style="display:none"></audio>
                    </div>
                    <div class="col-12 d-flex justify-content-center gap-2 mt-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm rounded-circle" id="toggleVideo" title="Toggle Video">
                            <i class="fas fa-video"></i>
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm rounded-circle" id="toggleMute" title="Mute">
                            <i class="fas fa-microphone"></i>
                        </button>
                        <button type="button" class="btn btn-danger btn-sm rounded-circle" id="endCall" title="End Call">
                            <i class="fas fa-phone-slash"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="offcanvas offcanvas-end offcanvas-lg p-3" tabindex="-1" id="infoSidebar">
  <div class="offcanvas-header d-lg-none">
    <h5 class="offcanvas-title">Info</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
  </div>
  <div class="offcanvas-body p-0">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h6 class="mb-0"><i class="fas fa-shield-alt"></i> Encryption Status</h6>
                <div>
                    <button class="btn btn-sm btn-outline-info me-2" id="validate-encryption-btn" title="Test encryption with {{ recipient }}">
                        <i class="fas fa-check-circle"></i> Validate
                    </button>
                    <button class="btn btn-sm btn-outline-primary" id="toggle-keys-btn">
                        <i class="fas fa-key"></i> Show My Keys
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="encryption-keys" class="mb-3 d-none">
                    <div class="mb-3">
                        <label class="form-label small text-muted mb-1">Public Key</label>
                        <div class="input-group mb-2">
                            <textarea id="public-key" class="form-control font-monospace small" rows="4" readonly></textarea>
                            <button class="btn btn-outline-secondary copy-btn" data-target="public-key" type="button" title="Copy to clipboard">
                                <i class="far fa-copy"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <label class="form-label small text-muted mb-1">Private Key</label>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="show-private-key">
                                <label class="form-check-label small" for="show-private-key">Show</label>
                            </div>
                        </div>
                        <div class="input-group">
                            <textarea id="private-key" class="form-control font-monospace small" rows="4" readonly></textarea>
                            <button class="btn btn-outline-secondary copy-btn" data-target="private-key" type="button" title="Copy to clipboard">
                                <i class="far fa-copy"></i>
                            </button>
                        </div>
                        <div class="form-text text-warning small">
                            <i class="fas fa-exclamation-triangle"></i> Keep your private key secret and never share it with anyone.
                        </div>
                    </div>
                    <hr>
                </div>
                <div id="validation-results" class="d-none mb-3">
                    <div class="card border-0 bg-light">
                        <div class="card-body p-3">
                            <h6 class="card-title d-flex justify-content-between align-items-center mb-2">
                                <span><i class="fas fa-shield-vault"></i> Encryption Test</span>
                                <span id="validation-status" class="badge">Testing...</span>
                            </h6>
                            <div id="validation-details" class="small">
                                <div class="mb-2">
                                    <span class="text-muted">Original:</span>
                                    <code id="test-original" class="ms-1 text-break"></code>
                                </div>
                                <div class="mb-2">
                                    <span class="text-muted">Encrypted:</span>
                                    <code id="test-encrypted" class="ms-1 text-break small"></code>
                                </div>
                                <div class="mb-2">
                                    <span class="text-muted">Decrypted:</span>
                                    <code id="test-decrypted" class="ms-1 text-break"></code>
                                </div>
                                <div id="validation-message" class="mt-2"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="encryption-log" style="height: 200px; overflow-y: auto;">
                    <div class="encryption-log">
                        <i class="fas fa-info-circle"></i> Ready for secure messaging
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <h6><i class="fas fa-chart-line"></i> Session Stats</h6>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-6">
                        <div class="h5 text-success" id="messages-sent">0</div>
                        <small>Sent</small>
                    </div>
                    <div class="col-6">
                        <div class="h5 text-info" id="messages-received">0</div>
                        <small>Received</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<style>
    /* Call controls styling */
    #callControls {
        transition: all 0.3s ease;
        max-width: 400px;
    }
    #callControls.minimized {
        transform: translateY(calc(100% - 45px));
    }
    #callControls .card-header {
        cursor: pointer;
        background: var(--bs-primary);
        color: white;
    }
    #callControls .card-body {
        display: none;
    }
    #callControls:not(.minimized) .card-body {
        display: block;
    }
    #localVideo {
        transition: all 0.3s ease;
    }
    #localVideo.minimized {
        width: 80px !important;
        height: 60px !important;
        bottom: 20px !important;
        right: 10px !important;
    }
    /* Animation for incoming call */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
    .pulse-animation {
        animation: pulse 1.5s infinite;
    }
    /* Call modal styling */
    #callModal .modal-content {
        border: none;
        border-radius: 12px;
        overflow: hidden;
    }
    #callModal .modal-header {
        border-bottom: none;
        justify-content: center;
        background: var(--bs-primary);
        color: white;
    }
    #callModal .btn-close {
        position: absolute;
        right: 1rem;
        top: 1rem;
        filter: invert(1) grayscale(100%) brightness(200%);
    }
    #callModal .btn-lg {
        width: 60px;
        height: 60px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    #callModal .btn-success {
        background-color: #28a745;
        border-color: #28a745;
    }
    #callModal .btn-danger {
        background-color: #dc3545;
        border-color: #dc3545;
    }
</style>

<script>
    const socket = io();
    const currentUser = '{{ user.username }}';
    const recipient = '{{ recipient }}';
    
    // Online users tracking
    let sidebarOnlineUsers = new Set();
    
    // WebRTC variables
    let peerConnection;
    let localStream;
    let isCaller = false;
    let currentCallType = '';
    let callStartTime;
    let callTimer;
    let isMuted = false;
    let isVideoOff = false;
    let callInitiator = null;
    
    // Configuration for WebRTC
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
        ]
    };
    
    // Online users functions
    function updateSidebarOnlineUsers(users) {
        console.log('Updating sidebar online users:', users);
        if (Array.isArray(users)) {
            sidebarOnlineUsers = new Set(users.filter(user => user !== currentUser));
            displaySidebarOnlineUsers();
        }
    }
    
    function displaySidebarOnlineUsers() {
        const container = document.getElementById('sidebar-online-users');
        const countElement = document.getElementById('sidebar-online-count');
        const noUsersElement = document.getElementById('sidebar-no-users');
        
        if (!container) return;
        
        const userCount = sidebarOnlineUsers.size;
        countElement.textContent = userCount;
        
        if (userCount === 0) {
            noUsersElement.style.display = 'block';
            // Clear any existing user items
            const userItems = container.querySelectorAll('.online-user-item');
            userItems.forEach(item => item.remove());
        } else {
            noUsersElement.style.display = 'none';
            
            // Clear existing items
            const userItems = container.querySelectorAll('.online-user-item');
            userItems.forEach(item => item.remove());
            
            // Add user items
            Array.from(sidebarOnlineUsers).forEach(username => {
                const userItem = createSidebarUserItem(username);
                container.appendChild(userItem);
            });
        }
    }
    
    function createSidebarUserItem(username) {
        const item = document.createElement('a');
        item.className = 'online-user-item';
        item.href = `/chat/${username}`;
        item.title = `Chat with ${username}`;
        
        const avatar = document.createElement('div');
        avatar.className = 'online-user-avatar';
        avatar.textContent = username.charAt(0).toUpperCase();
        
        const name = document.createElement('div');
        name.className = 'online-user-name';
        name.textContent = username;
        
        item.appendChild(avatar);
        item.appendChild(name);
        
        return item;
    }
    
    // Initialize call controls
    function initCallControls() {
        // Start call buttons
        document.getElementById('startVoiceCall')?.addEventListener('click', () => startCall('voice'));
        document.getElementById('startVideoCall')?.addEventListener('click', () => startCall('video'));
        
        // Call control buttons
        document.getElementById('endCall')?.addEventListener('click', endCall);
        document.getElementById('acceptCall')?.addEventListener('click', acceptCall);
        document.getElementById('rejectCall')?.addEventListener('click', rejectCall);
        
        // Toggle buttons
        document.getElementById('toggleMute')?.addEventListener('click', toggleMute);
        document.getElementById('toggleVideo')?.addEventListener('click', toggleVideo);
        document.getElementById('minimizeCall')?.addEventListener('click', toggleCallMinimize);
    }
    
    // Start a new call
    async function startCall(type) {
        try {
            currentCallType = type;
            isCaller = true;
            
            // Get local media stream
            const constraints = {
                audio: true,
                video: type === 'video' ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                } : false
            };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Display local video if it's a video call
            if (type === 'video') {
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
            }
            
            // Create peer connection
            createPeerConnection();
            
            // Add local stream to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // Show call controls
            document.getElementById('callControls').style.display = 'block';
            document.getElementById('callStatus').textContent = `Calling ${recipient}...`;
            
            // Notify the callee that we want to start a call.  The actual WebRTC
            // offer will be created *after* they accept so we don't waste ICE
            // gathering effort if they decline.
            socket.emit('start_call', {
                from: currentUser,
                to: recipient,
                type: type
            });
            
            // Start call timer
            callStartTime = new Date();
            updateCallTimer();
            
        } catch (err) {
            console.error('Error starting call:', err);
            alert('Could not access your camera/microphone. Please check your permissions.');
            endCall('Failed to start call');
        }
    }
    
    // Create a new RTCPeerConnection
    function createPeerConnection() {
        // Close existing connection if any
        if (peerConnection) {
            peerConnection.close();
        }
        
        // Create new peer connection
        peerConnection = new RTCPeerConnection(configuration);
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Sending ICE candidate:', event.candidate);
                socket.emit('ice_candidate', {
                    target: isCaller ? recipient : callInitiator,
                    candidate: event.candidate,
                    caller: isCaller ? currentUser : callInitiator,
                    callee: isCaller ? recipient : currentUser
                });
            }
        };
        
        // Handle remote stream
        peerConnection.ontrack = (event) => {
            console.log('Received remote track:', event.track.kind, 'from stream:', event.streams[0]);
            
            if (event.streams && event.streams[0]) {
                const remoteStream = event.streams[0];
                const remoteVideo = document.getElementById('remoteVideo');
                
                // Set the remote stream to the video element (handles both audio and video)
                if (remoteVideo) {
                    remoteVideo.srcObject = remoteStream;
                    remoteVideo.autoplay = true;
                    remoteVideo.playsInline = true;
                    remoteVideo.muted = false; // keep audio

                    const tryPlay = () => {
                        const playPromise = remoteVideo.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(err => {
                                console.warn('play() interrupted, will retry on user gesture or canplay', err);
                            });
                        }
                    };

                    if (remoteVideo.readyState >= 2) {
                        // metadata already loaded
                        tryPlay();
                    } else {
                        remoteVideo.addEventListener('loadedmetadata', () => {
                            tryPlay();
                        }, { once: true });
                    }
                    
                    console.log('Remote stream set to video element');
                    
                    // Show/hide video element based on call type and video tracks
                    const hasVideo = remoteStream.getVideoTracks().length > 0;
                    if (currentCallType === 'video' && hasVideo) {
                        remoteVideo.style.display = 'block';
                    } else {
                        remoteVideo.style.display = 'none';
                    }

                    // For voice calls or streams without video, ensure audio is attached
                    if (!hasVideo || currentCallType === 'voice') {
                        const remoteAudio = document.getElementById('remoteAudio');
                        if (remoteAudio) {
                            remoteAudio.srcObject = remoteStream;
                            remoteAudio.autoplay = true;
                            remoteAudio.play().catch(e => console.error('Error playing remote audio:', e));
                        }
                    }
                }
            }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);
            switch(peerConnection.connectionState) {
                case 'connected':
                    console.log('Peer connection established');
                    updateCallUI('active');
                    break;
                case 'disconnected':
                case 'failed':
                    console.log('Peer connection failed or disconnected');
                    endCall('Connection lost');
                    break;
                case 'closed':
                    console.log('Peer connection closed');
                    break;
            }
        };
        
        // Handle ICE connection state changes
        peerConnection.oniceconnectionstatechange = () => {
            console.log('ICE connection state:', peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') {
                console.log('ICE connection failed');
                endCall('Connection failed');
            }
        };
    }
    let messagesSent = 0;
    let messagesReceived = 0;
    
    // Toggle mute/unmute
    function toggleMute() {
        if (localStream) {
            const audioTracks = localStream.getAudioTracks();
            audioTracks.forEach(track => {
                track.enabled = !track.enabled;
            });
            isMuted = !isMuted;
            const icon = document.querySelector('#toggleMute i');
            icon.className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone';
        }
    }
    
    // Toggle video on/off
    function toggleVideo() {
        if (localStream) {
            const videoTracks = localStream.getVideoTracks();
            if (videoTracks.length > 0) {
                videoTracks[0].enabled = !videoTracks[0].enabled;
                isVideoOff = !videoTracks[0].enabled;
                const icon = document.querySelector('#toggleVideo i');
                icon.className = isVideoOff ? 'fas fa-video-slash' : 'fas fa-video';
            }
        }
    }
    
    // Toggle call controls minimize/expand
    function toggleCallMinimize() {
        const callControls = document.getElementById('callControls');
        callControls.classList.toggle('minimized');
    }
    
    // Update call timer
    function updateCallTimer() {
        if (callStartTime) {
            const now = new Date();
            const duration = Math.floor((now - callStartTime) / 1000);
            const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
            const seconds = (duration % 60).toString().padStart(2, '0');
            document.getElementById('callStatus').textContent = `Call in progress: ${minutes}:${seconds}`;
            callTimer = setTimeout(updateCallTimer, 1000);
        }
    }
    
    // Accept an incoming call
    async function acceptCall() {
        try {
            const callModal = bootstrap.Modal.getInstance(document.getElementById('callModal'));
            callModal.hide();
            
            // Get local media stream
            const constraints = {
                audio: true,
                video: currentCallType === 'video' ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                } : false
            };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Display local video if it's a video call
            if (currentCallType === 'video') {
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
            }
            
            // Create peer connection
            createPeerConnection();
            
            // Add local stream to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // Show call controls
            document.getElementById('callControls').style.display = 'block';
            document.getElementById('callStatus').textContent = `In call with ${callInitiator}`;
            
            // Notify the caller that the call was accepted
            socket.emit('accept_call', {
                caller: callInitiator,
                callee: currentUser
            });
            
            // Start call timer
            callStartTime = new Date();
            updateCallTimer();
            
        } catch (err) {
            console.error('Error accepting call:', err);
            alert('Could not access your camera/microphone. Please check your permissions.');
            rejectCall();
        }
    }
    
    // Reject an incoming call
    function rejectCall() {
        const callModal = bootstrap.Modal.getInstance(document.getElementById('callModal'));
        callModal.hide();
        
        // Notify the caller that the call was rejected
        socket.emit('reject_call', {
            caller: callInitiator,
            callee: currentUser,
            reason: 'rejected'
        });
        
        // Reset call state
        callInitiator = null;
        currentCallType = '';
    }
    
    // End the current call
    function endCall(reason = 'Call ended', fromRemote = false) {
        console.log('Ending call with reason:', reason, 'fromRemote:', fromRemote);
        
        // If we're already in the process of ending the call, don't do it again
        if (window.endingCall) {
            console.log('Call termination already in progress');
            return;
        }
        
        window.endingCall = true;
        
        try {
            // Stop local stream
            if (localStream) {
                console.log('Stopping local stream tracks');
                localStream.getTracks().forEach(track => {
                    try {
                        track.stop();
                        track.enabled = false;
                    } catch (e) {
                        console.error('Error stopping track:', e);
                    }
                });
                localStream = null;
            }
            
            // Close peer connection
            if (peerConnection) {
                console.log('Closing peer connection');
                // Remove all event listeners to prevent memory leaks
                peerConnection.ontrack = null;
                peerConnection.onicecandidate = null;
                peerConnection.oniceconnectionstatechange = null;
                peerConnection.onsignalingstatechange = null;
                peerConnection.onicegatheringstatechange = null;
                peerConnection.onconnectionstatechange = null;
                
                // Close connection
                try {
                    const senders = peerConnection.getSenders ? peerConnection.getSenders() : [];
                    senders.forEach(sender => {
                        if (sender.track) {
                            try {
                                sender.track.stop();
                            } catch (e) {
                                console.error('Error stopping sender track:', e);
                            }
                        }
                    });
                } catch (e) {
                    console.error('Error getting senders:', e);
                }
                
                try {
                    peerConnection.close();
                } catch (e) {
                    console.error('Error closing peer connection:', e);
                } finally {
                    peerConnection = null;
                }
            }
            
            // Clear timer
            if (callTimer) {
                console.log('Clearing call timer');
                clearTimeout(callTimer);
                callTimer = null;
            }
            
            // Reset video elements
            const remoteVideo = document.getElementById('remoteVideo');
            const localVideo = document.getElementById('localVideo');
            
            if (remoteVideo) {
                try {
                    remoteVideo.srcObject = null;
                    remoteVideo.pause();
                } catch (e) {
                    console.error('Error resetting remote video:', e);
                }
            }
            
            if (localVideo) {
                try {
                    localVideo.srcObject = null;
                    localVideo.pause();
                } catch (e) {
                    console.error('Error resetting local video:', e);
                }
            }
            
            // Hide call controls
            const callControls = document.getElementById('callControls');
            if (callControls) {
                callControls.style.display = 'none';
            }
            
            // Notify the other peer if we're in a call and this is a local end call
            if (!fromRemote && (isCaller || callInitiator) && (recipient || callInitiator)) {
                const targetUser = isCaller ? recipient : callInitiator;
                console.log('Notifying peer of call end:', targetUser);
                
                socket.emit('end_call', {
                    caller: isCaller ? currentUser : callInitiator,
                    callee: targetUser,
                    reason: reason,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Reset call state
            isCaller = false;
            currentCallType = '';
            callStartTime = null;
            callInitiator = null;
            
            // Close any open call modal
            const callModal = bootstrap.Modal.getInstance(document.getElementById('callModal'));
            if (callModal) {
                callModal.hide();
            }
            
            // Show notification
            if (reason && reason !== 'Call ended') {
                console.log('Call ended:', reason);
                try {
                    if (Notification.permission === 'granted') {
                        new Notification('Call ended', {
                            body: reason,
                            icon: '/static/favicon.ico'
                        });
                    }
                } catch (e) {
                    console.error('Error showing notification:', e);
                }
            }
            
            // Update UI
            updateCallUI('ended');
            
            console.log('Call cleanup complete');
            
        } catch (e) {
            console.error('Error during call cleanup:', e);
        } finally {
            window.endingCall = false;
        }
    }
    
    // Initialize call controls when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        initCallControls();
    });
    
    // WebRTC signaling event handlers
    socket.on('incoming_call', (data) => {
        callInitiator = data.from;
        currentCallType = data.type;
        
        // Show call modal
        const callModal = new bootstrap.Modal(document.getElementById('callModal'));
        document.getElementById('callerName').textContent = callInitiator;
        document.getElementById('callType').textContent = `Incoming ${data.type} Call`;
        document.getElementById('callerAvatar').src = data.caller_avatar || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(callInitiator) + '&background=random';
        
        callModal.show();
        
        // Auto-reject after 30 seconds if not answered
        setTimeout(() => {
            if (document.getElementById('callModal').classList.contains('show')) {
                rejectCall();
                callModal.hide();
            }
        }, 30000);
    });
    
    socket.on('call_accepted', async (data) => {
        console.log('Call accepted by peer');
        document.getElementById('callStatus').textContent = `In call with ${recipient}`;
        
        try {
            if (isCaller && peerConnection) {
                console.log('Creating WebRTC offer after acceptance');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                console.log('Sending WebRTC offer');
                socket.emit('webrtc_offer', {
                    target: recipient,
                    caller: currentUser,
                    callee: recipient,
                    sdp: offer.sdp
                });
            }
        } catch (err) {
            console.error('Error creating / sending offer:', err);
            endCall('Connection error');
        }
    });
    
    socket.on('call_rejected', (data) => {
        alert(`${data.callee} rejected your call`);
        endCall('Call rejected');
    });
    
    socket.on('call_ended', (data) => {
        const reason = data.reason || 'Call ended by peer';
        const endedBy = data.ended_by || 'peer';
        console.log('Received call_ended event:', { reason, endedBy, data });
        
        // Only show a notification if we didn't initiate the call end
        if (endedBy !== currentUser) {
            try {
                if (Notification.permission === 'granted') {
                    const notification = new Notification('Call ended', {
                        body: reason,
                        icon: '/static/favicon.ico'
                    });
                    
                    // Close the notification after 5 seconds
                    setTimeout(() => {
                        try { notification.close(); } catch (e) {}
                    }, 5000);
                }
            } catch (e) {
                console.error('Error showing notification:', e);
            }
        }
        
        // End the call with the reason
        endCall(reason, true);
        
        // Update the UI
        updateCallUI('ended');
        
        // If there's a call modal open, close it
        try {
            const callModal = bootstrap.Modal.getInstance(document.getElementById('callModal'));
            if (callModal) {
                callModal.hide();
            }
        } catch (e) {
            console.error('Error closing call modal:', e);
        }
        
        console.log('Call ended:', { reason, endedBy });
    });
    
    socket.on('webrtc_offer', async (data) => {
        try {
            console.log('Received WebRTC offer from:', data.caller);
            
            if (!peerConnection) {
                createPeerConnection();
            }
            
            // Set remote description
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: 'offer',
                sdp: data.sdp
            }));
            
            console.log('Remote description set, creating answer');
            
            // Create and send answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            console.log('Sending WebRTC answer to:', data.caller);
            
            socket.emit('webrtc_answer', {
                target: data.caller,
                caller: currentUser,
                callee: data.caller,
                sdp: answer.sdp
            });
            
        } catch (err) {
            console.error('Error handling WebRTC offer:', err);
            endCall('Error establishing connection');
        }
    });
    
    socket.on('webrtc_answer', async (data) => {
        try {
            console.log('Received WebRTC answer from:', data.caller);
            
            if (peerConnection) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: data.sdp
                }));
                
                console.log('Remote description set from answer');
            }
        } catch (err) {
            console.error('Error handling WebRTC answer:', err);
            endCall('Error establishing connection');
        }
    });
    
    socket.on('ice_candidate', async (data) => {
        try {
            console.log('Received ICE candidate:', data.candidate);
            
            if (peerConnection && peerConnection.remoteDescription) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('ICE candidate added successfully');
            } else {
                console.log('Peer connection not ready for ICE candidate, queuing...');
                // You might want to queue candidates here if needed
            }
        } catch (err) {
            console.error('Error adding ICE candidate:', err);
        }
    });
    
    // Utility function to handle media device errors
    function handleMediaError(error) {
        console.error('Media error:', error);
        let errorMessage = 'Error accessing media devices. ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Please allow camera/microphone access to make calls.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage += 'Required media devices not found. Please check your camera/microphone.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage += 'Could not start video/audio. The device may be in use by another application.';
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
            errorMessage += 'Constraints could not be satisfied by available devices.';
        } else if (error.name === 'TypeError') {
            errorMessage += 'Invalid constraints specified.';
        } else {
            errorMessage += error.message || 'Unknown error occurred.';
        }
        
        alert(errorMessage);
        endCall('Media error: ' + errorMessage);
        return errorMessage;
    }
    
    // Function to check media device permissions
    async function checkMediaPermissions() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const hasAudio = devices.some(device => device.kind === 'audioinput');
            const hasVideo = devices.some(device => device.kind === 'videoinput');
            
            if (!hasAudio) {
                throw new Error('No audio input devices found');
            }
            
            return { hasAudio, hasVideo };
        } catch (err) {
            console.error('Error checking media devices:', err);
            handleMediaError(err);
            throw err;
        }
    }
    
    // Function to handle call timeouts
    function setupCallTimeout(timeout = 30000) {
        return setTimeout(() => {
            if (peerConnection && peerConnection.connectionState !== 'connected') {
                endCall('Call timed out');
                alert('Call timed out. The other party did not respond.');
            }
        }, timeout);
    }
    
    // Update UI based on call state
    function updateCallUI(state) {
        const callControls = document.getElementById('callControls');
        const callStatus = document.getElementById('callStatus');
        const startCallButtons = document.querySelectorAll('#startVoiceCall, #startVideoCall');
        
        switch(state) {
            case 'starting':
                callStatus.textContent = 'Connecting...';
                startCallButtons.forEach(btn => btn.disabled = true);
                break;
                
            case 'active':
                callStatus.textContent = `In call with ${isCaller ? recipient : callInitiator}`;
                callControls.style.display = 'block';
                startCallButtons.forEach(btn => btn.disabled = true);
                break;
                
            case 'ended':
                callStatus.textContent = 'Call ended';
                callControls.style.display = 'none';
                startCallButtons.forEach(btn => btn.disabled = false);
                break;
                
            case 'error':
                callStatus.textContent = 'Call failed';
                callControls.style.display = 'none';
                startCallButtons.forEach(btn => btn.disabled = false);
                break;
        }
    }
    
    // DOM elements
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const messageList = document.getElementById('message-list');
// auto-grow textarea height
messageInput.addEventListener('input', () => {
    messageInput.style.height = 'auto';
    messageInput.style.height = messageInput.scrollHeight + 'px';
});
    const encryptionLog = document.getElementById('encryption-log');
    const chatContainer = document.getElementById('chat-messages');
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        loadChatHistory();
        messageInput.focus();
    });
    
    // Handle Enter key in message input
    document.getElementById('message-input').addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const msg = this.value.trim();
            if (msg) {
                sendMessage(msg);
                this.value = '';
                this.style.height = 'auto';
            }
        }
    });

// Handle send message button click
document.getElementById('send-button').addEventListener('click', function() {
    const messageInput = document.getElementById('message-input');
    const message = messageInput.value.trim();

    if (message) {
        sendMessage(message);
        messageInput.value = '';
        messageInput.style.height = 'auto';
        }
    });
    
    // Handle file input change
    document.getElementById('file-input').addEventListener('change', async function() {
        const file = this.files[0];
        const fileInfo = document.getElementById('file-info');
        
        if (!file) {
            fileInfo.textContent = '';
            return;
        }
        
        // Check file size (10MB max)
        if (file.size > 10 * 1024 * 1024) {
            fileInfo.textContent = 'File too large (max 10MB)';
            fileInfo.className = 'text-danger fst-italic';
            this.value = '';
            return;
        }
        
        fileInfo.textContent = `Uploading ${file.name} (${formatFileSize(file.size)})...`;
        fileInfo.className = 'text-primary fst-italic';
        
        // Show progress bar
        const progressContainer = document.getElementById('upload-progress-container');
        const progressBar = document.getElementById('upload-progress');
        progressContainer.classList.remove('d-none');
        
        // Create form data
        const formData = new FormData();
        formData.append('file', file);
        formData.append('recipient', '{{ recipient }}');
        
        try {
            // Upload the file
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
                // Note: Don't set Content-Type header when using FormData
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Add file message to chat
                const fileLink = `<a href="${result.download_url}" target="_blank" class="text-primary">${file.name}</a>`;
                
                // Create a proper message object that matches what the server would send
                const messageData = {
                    sender: '{{ user.username }}',
                    content: `📎 ${fileLink} (${formatFileSize(file.size)})`,
                    is_file: true,
                    file_info: {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        url: result.download_url
                    },
                    timestamp: new Date().toISOString(),
                    status: 'delivered'
                };
                
                // Add message to UI
                addMessageToUI(
                    messageData.sender,
                    messageData.content,
                    'sent',
                    messageData.timestamp,
                    true,  // isPlaintext
                    null,  // messageId
                    'delivered',  // status
                    true
                );
                
                // Reset file input and show success message
                this.value = '';
                fileInfo.textContent = 'File sent successfully';
                fileInfo.className = 'text-success fst-italic';
                
                // Clear success message after 3 seconds
                setTimeout(() => {
                    if (fileInfo.textContent === 'File sent successfully') {
                        fileInfo.textContent = '';
                    }
                }, 3000);
                
                // Scroll to bottom of chat
                scrollToBottom();
                
            } else {
                throw new Error(result.message || 'Failed to upload file');
            }
        } catch (error) {
            console.error('File upload error:', error);
            fileInfo.textContent = 'Upload failed: ' + (error.message || 'Unknown error');
            fileInfo.className = 'text-danger fst-italic';
        } finally {
            progressContainer.classList.add('d-none');
            progressBar.style.width = '0%';
        }
    });
    
    // Trigger file input when attach button is clicked
    document.getElementById('attach-file-btn').addEventListener('click', function() {
        document.getElementById('file-input').click();
    });
    
    // Format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Handle message sending
    function sendMessage(message) {
        if (!message.trim()) return;
        
        const messageId = 'msg-' + Date.now();
        const timestamp = new Date().toISOString();
        
        // Check if this is an AI message
        const isAIMessage = message.trim().startsWith('@SecureAI ');
        
        // Add message to UI immediately only if it's not an AI message
        // AI messages will be handled by the AI handler
        if (!isAIMessage) {
            addMessageToUI('{{ user.username }}', message, 'sent', timestamp, true, messageId, 'sending');
        }
        
        // Send message via Socket.IO
        socket.emit('send_message', {
            recipient: '{{ recipient }}',
            message: message,
            message_id: messageId
        });
        
        // Clear input and scroll to bottom
        document.getElementById('message-input').value = '';
        scrollToBottom();
    }
    
    function addMessageToUI(sender, content, type, timestamp, isPlaintext = false, messageId = null, status = null, isFile = false, isAI = false, isAIPrompt = false) {
        // If message with this ID already exists, don't add it again
        if (messageId && document.querySelector(`[data-message-id="${messageId}"]`)) {
            return null;
        }
        // Generate a unique ID for the message if not provided
        messageId = messageId || 'msg-' + Date.now();
        messageId = messageId || generateMessageId();
        const isSent = type === 'sent';
        const messageElement = document.createElement('div');
        messageElement.className = `d-flex ${isSent ? 'justify-content-end' : 'justify-content-start'} mb-3`;
        messageElement.setAttribute('data-message-id', messageId);
        
        const messageContent = document.createElement('div');
        let bubbleClass = 'message-bubble';
        if (isSent) {
            bubbleClass += ' message-sent';
        } else if (isAI || isAIPrompt) {
            bubbleClass += ' message-ai';
        } else {
            bubbleClass += ' message-received';
        }
        messageContent.className = bubbleClass;
        
        // Add timestamp
        const timeElement = document.createElement('div');
        timeElement.className = 'message-timestamp';
        timeElement.textContent = formatTime(timestamp);
        
        const senderElement = document.createElement('div');
        senderElement.className = 'message-sender d-none';
        senderElement.textContent = sender + ':';
        
        // Add AI header only for AI responses
        if (isAI && !isAIPrompt) {
            const aiHeader = document.createElement('div');
            aiHeader.className = 'fw-bold mb-1 opacity-75';
            aiHeader.innerHTML = '<i class="fas fa-robot me-1"></i>SecureAI Answer';
            messageContent.appendChild(aiHeader);
        }
        
        const contentElement = document.createElement('div');
        contentElement.className = 'message-text';
        
        // If this is a file message, render the HTML so the link is clickable
        if (isFile) {
            contentElement.innerHTML = content; // safe because server already sanitized the link
        } else if (isPlaintext) {
            const codeMatch = content.trim().match(/^@\.(\w+)\s([\s\S]*)/);
            if (codeMatch) {
                const ext = codeMatch[1];
                const codeBody = codeMatch[2];
                // build snippet
                const header = document.createElement('div');
                header.className = 'd-flex justify-content-between align-items-center bg-light border-bottom px-2 py-1 code-header';
                header.innerHTML = `<strong>.${ext}</strong><div><button type="button" class="btn btn-sm btn-link copy-code"><i class="fas fa-copy"></i></button><a href="#" class="btn btn-sm btn-link download-code" role="button"><i class="fas fa-download"></i></a></div>`;
                const pre = document.createElement('pre');
                pre.className = 'm-0 p-2';
                const codeEl = document.createElement('code');
                codeEl.textContent = codeBody;
                pre.appendChild(codeEl);
                contentElement.appendChild(header);
                contentElement.appendChild(pre);
                // events
                header.querySelector('.copy-code').addEventListener('click', (e)=>{e.stopPropagation(); navigator.clipboard.writeText(codeBody);});
                header.querySelector('.download-code').addEventListener('click',(e)=>{e.stopPropagation(); const blob=new Blob([codeBody],{type:'text/plain'}); const url=URL.createObjectURL(blob); e.currentTarget.href=url; e.currentTarget.download=`snippet.${ext}`;});
            } else {
                // Check if message contains @SecureAI
                if (content.startsWith('@SecureAI')) {
                    // Create a wrapper span for the entire message
                    const wrapper = document.createElement('span');
                    wrapper.className = 'message-content';
                    
                    // Add @SecureAI with special class
                    const aiTag = document.createElement('span');
                    aiTag.className = 'secure-ai-tag';
                    aiTag.textContent = '@SecureAI';
                    wrapper.appendChild(aiTag);
                    
                    // Add the rest of the message with markdown support for AI responses
                    const messageContent = content.substring(10); // 10 is length of '@SecureAI '
                    if (isAI) {
                        // Use marked.js to render markdown for AI responses
                        wrapper.innerHTML += marked.parse(messageContent);
                    } else {
                        // For user's AI prompts, just show as plain text
                        wrapper.appendChild(document.createTextNode(' ' + messageContent));
                    }
                    contentElement.appendChild(wrapper);
                } else if (isAI) {
                    // For AI responses that don't start with @SecureAI
                    contentElement.innerHTML = marked.parse(content);
                } else {
                    // For regular messages, escape HTML to prevent XSS
                    contentElement.textContent = content;
                }
            }
        } else {
            contentElement.textContent = 'Encrypted message (click to decrypt)';
        }
        
        if (!isPlaintext && !isFile) {
            contentElement.style.cursor = 'pointer';
            contentElement.onclick = () => decryptMessage(messageElement, content, messageId);
            contentElement.innerHTML += ' <i class="fas fa-lock"></i>';
        }
        
        // Add status indicator for sent messages
        let statusElement = null;
        if (isSent) {
            statusElement = document.createElement('div');
            statusElement.className = 'message-status';
            
            const statusIcon = document.createElement('i');
            statusIcon.className = 'fas';
            
            // Set initial status
            updateMessageStatus(statusElement, status || 'sending');
            
            statusElement.appendChild(document.createTextNode(' '));
            statusElement.appendChild(document.createTextNode(status === 'delivered' ? '' : 'Not Delivered'));
        }
        
        // Add content and timestamp to the message
        messageContent.appendChild(contentElement);
        messageContent.appendChild(timeElement);
        
        // Add status indicator if it's a sent message
        if (statusElement) {
            const statusContainer = document.createElement('div');
            statusContainer.className = 'message-status mt-1 text-end';
            statusContainer.appendChild(statusElement);
            messageContent.appendChild(statusContainer);
        }
        
        // Add the message content to the message element
        messageElement.appendChild(messageContent);
        
        chatContainer.appendChild(messageElement);
        scrollToBottom();
        
        // Store reference to status element for updates
        if (statusElement) {
            messageElement._statusElement = statusElement;
        }
        
        return messageElement; // Return the message element for status updates
    }
    
    // AI Typing Indicator Functions
    function showAITyping() {
        // Remove existing typing indicator
        hideAITyping();
        
        const typingElement = document.createElement('div');
        typingElement.id = 'ai-typing-indicator';
        typingElement.className = 'd-flex justify-content-start mb-3';
        
        const typingBubble = document.createElement('div');
        typingBubble.className = 'typing-indicator';
        typingBubble.innerHTML = `
            <div class="fw-bold mb-1 opacity-75">
                <i class="fas fa-robot me-1"></i>SecureAI is thinking...
            </div>
            <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        
        typingElement.appendChild(typingBubble);
        chatContainer.appendChild(typingElement);
        scrollToBottom();
    }
    
    function hideAITyping() {
        const typingIndicator = document.getElementById('ai-typing-indicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }
    
    function updateMessageStatus(statusElement, status) {
        if (!statusElement) return;
        
        const icon = statusElement.querySelector('i');
        if (!icon) return;
        
        // Remove all status classes
        icon.className = 'fas';
        
        // Add appropriate icon and class based on status
        if (status === 'delivered') {
            icon.classList.add('fa-check-circle', 'text-success');
            statusElement.title = 'Delivered';
        } else if (status === 'sent') {
            icon.classList.add('fa-check', 'text-muted');
            statusElement.title = 'Sent';
        } else {
            icon.classList.add('fa-clock', 'text-muted');
            statusElement.title = 'Sending...';
        }
        
        // Update status text if it exists
        const textNode = Array.from(statusElement.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
        if (textNode) {
            textNode.textContent = status === 'delivered' ? ' Delivered' : ' Sending...';
        }
    }
    
    async function createParticles(element) {
        const rect = element.getBoundingClientRect();
        const particleCount = Math.min(100, rect.width * rect.height / 50); // Adjust density based on element size
        
        // Create a container for the particles
        const container = document.createElement('div');
        container.className = 'particle-container';
        container.style.position = 'absolute';
        container.style.top = '0';
        container.style.left = '0';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.pointerEvents = 'none';
        container.style.overflow = 'hidden';
        
        // Create particles
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Position particles randomly within the element
            const x = Math.random() * rect.width;
            const y = Math.random() * rect.height;
            
            // Calculate target position (outward from center)
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const angle = Math.atan2(y - centerY, x - centerX);
            const distance = Math.min(200, Math.max(rect.width, rect.height) * 0.8);
            
            // Set initial position and target
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
            particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
            particle.style.animationDelay = `${Math.random() * 0.3}s`;
            
            container.appendChild(particle);
        }
        
        element.style.position = 'relative';
        element.appendChild(container);
        
        // Clean up after animation
        return new Promise(resolve => {
            setTimeout(() => {
                container.remove();
                resolve();
            }, 1000);
        });
    }
    
    async function decryptMessage(messageElement, encryptedContent, messageId) {
        const contentDiv = messageElement.querySelector('.message-text');
        if (!contentDiv) return;
        
        // Show loading state
        const originalContent = contentDiv.innerHTML;
        contentDiv.innerHTML = 'Decrypting... <i class="fas fa-spinner fa-spin"></i>';
        contentDiv.style.cursor = 'wait';
        
        try {
            // Create particle effect
            await createParticles(contentDiv);
            
            // Request decryption from server
            return new Promise((resolve) => {
                // Add error handler for decryption timeout
                const decryptTimeout = setTimeout(() => {
                    throw new Error('Decryption timed out');
                }, 10000); // 10 second timeout
                
                // Request decryption from server
                socket.emit('decrypt_message', {
                    encrypted_content: encryptedContent,
                    message_id: messageId
                });
                
                // Store the timeout ID so we can clear it if decryption succeeds
                messageElement._decryptTimeout = decryptTimeout;
                
                // Listen for decryption response
                const handleDecrypted = (data) => {
                    if (data.message_id === messageId) {
                        clearTimeout(decryptTimeout);
                        socket.off('message_decrypted', handleDecrypted);
                        
                        if (data.status === 'success') {
                            // Show decrypted content with fade-in effect
                            contentDiv.style.opacity = '0';
                            contentDiv.innerHTML = data.decrypted_content || 'Decryption failed';
                            contentDiv.style.cursor = 'default';
                            contentDiv.style.transition = 'opacity 0.3s ease';
                            
                            // Trigger reflow
                            void contentDiv.offsetWidth;
                            
                            // Fade in
                            contentDiv.style.opacity = '1';
                            
                            // Mark as decrypted
                            messageElement.classList.add('decrypted');
                        } else {
                            throw new Error(data.message || 'Decryption failed');
                        }
                        
                        resolve();
                    }
                };
                
                socket.on('message_decrypted', handleDecrypted);
            });
        } catch (error) {
            console.error('Decryption error:', error);
            contentDiv.innerHTML = `Error: ${error.message}. <a href="#" class="retry-decrypt" data-message-id="${messageId}">Retry</a>`;
            contentDiv.style.cursor = 'pointer';
            
            // Add retry handler
            const retryLink = contentDiv.querySelector('.retry-decrypt');
            if (retryLink) {
                retryLink.onclick = (e) => {
                    e.preventDefault();
                    decryptMessage(messageElement, encryptedContent, messageId);
                };
            }
        }
    }
    
    function addEncryptionLog(message, type = 'info') {
        const logDiv = document.createElement('div');
        logDiv.className = `encryption-log alert-${type}`;
        logDiv.innerHTML = `
            <div class="d-flex justify-content-between">
                <span>${message}</span>
                <small>${new Date().toLocaleTimeString()}</small>
            </div>
        `;
        
        encryptionLog.appendChild(logDiv);
        encryptionLog.scrollTop = encryptionLog.scrollHeight;
    }
    
    function updateStats() {
        document.getElementById('messages-sent').textContent = messagesSent;
        document.getElementById('messages-received').textContent = messagesReceived;
    }
    
    function scrollToBottom() {
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }
    
    function formatTime(timestamp) {
        return new Date(timestamp).toLocaleTimeString();
    }
    
    function generateMessageId() {
        return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    function loadChatHistory() {
        // Load messages via AJAX to avoid JSON parsing issues in template
        fetch(`/api/messages/{{ recipient }}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const messages = data.messages || [];
                    console.log('Loaded', messages.length, 'messages from API');
                    processMessages(messages);
                } else {
                    console.error('Failed to load messages:', data.message);
                    addEncryptionLog('❌ Failed to load chat history', 'danger');
                }
            })
            .catch(error => {
                console.error('Error loading messages:', error);
                addEncryptionLog('❌ Error loading chat history', 'danger');
            });
    }
    
    function processMessages(messages) {
        try {
            
            if (!Array.isArray(messages)) {
                console.error('Invalid messages format:', messages);
                addEncryptionLog('❌ Failed to load chat history: Invalid format', 'danger');
                return;
            }
            
            // Process messages in reverse chronological order
            messages.slice().reverse().forEach(msg => {
            if (!msg || typeof msg !== 'object') return;
            
            const isSent = (msg.sender === currentUser);
            
            if (msg.is_file && msg.file_info) {
                // Build file link
                const fi = msg.file_info;
                const fileLink = `<a href="${fi.download_url}" target="_blank" class="text-primary">${fi.filename}</a>`;
                addMessageToUI(
                    msg.sender || 'Unknown',
                    `📎 ${fileLink} (${formatFileSize(fi.size)})`,
                    isSent ? 'sent' : 'received',
                    msg.timestamp || new Date().toISOString(),
                    true, // isPlaintext
                    msg.message_id || null,
                    msg.delivered ? 'delivered' : 'sent',
                    true
                );
                return; // Skip encrypted handling
            }

    
                
                // Handle AI messages and regular messages
                const isAIResponse = msg.is_ai_response || false;
                const isAIPrompt = msg.is_ai_prompt || false;
                const isPlaintext = msg.is_plaintext || isAIResponse || isAIPrompt;
                
                addMessageToUI(
                    msg.sender || 'Unknown', 
                    msg.encrypted_content || '', 
                    isSent ? 'sent' : 'received', 
                    msg.timestamp || new Date().toISOString(),
                    isPlaintext, // AI messages are plaintext
                    msg.message_id || null,
                    msg.delivered ? 'delivered' : 'sent',
                    false, // isFile
                    isAIResponse, // isAI
                    isAIPrompt // isAIPrompt
                );
            });
            
            // Scroll to bottom after loading messages
            scrollToBottomDelayed();
        } catch (error) {
            console.error('Error loading chat history:', error);
            addEncryptionLog('❌ Failed to load chat history', 'danger');
        }
    }
    
    // Clear chat functionality
    document.getElementById('clearChatBtn')?.addEventListener('click', async function(e) {
        e.preventDefault();
        
        if (!confirm('Are you sure you want to clear all messages in this chat? This action cannot be undone.')) {
            return;
        }
        
        const clearBtn = this;
        const originalHtml = clearBtn.innerHTML;
        clearBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Clearing...';
        clearBtn.disabled = true;
        
        try {
            const response = await fetch('/api/chat/clear', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    other_user: '{{ recipient }}'
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Clear the chat UI
                document.getElementById('chat-messages').innerHTML = '';
                addEncryptionLog('Chat history has been cleared', 'info');
            } else {
                throw new Error(result.message || 'Failed to clear chat');
            }
        } catch (error) {
            console.error('Error clearing chat:', error);
            addEncryptionLog('❌ ' + (error.message || 'Failed to clear chat'), 'danger');
        } finally {
            clearBtn.innerHTML = originalHtml;
            clearBtn.disabled = false;
        }
    });
    
    // Handle chat cleared event from server
    socket.on('chat_cleared', function(data) {
        if (data.with_user === '{{ recipient }}' || data.from_user === '{{ recipient }}') {
            // Clear the chat UI if we're in the chat that was cleared
            const messageList = document.getElementById('message-list');
            if (messageList) {
                messageList.innerHTML = '';
            }
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            addEncryptionLog('Chat history has been cleared', 'info');
        }
    });
    
    // Socket event handlers
    socket.on('encryption_status', function(data) {
        addEncryptionLog(
            `✅ Message encrypted successfully (${data.original_length} → ${data.encrypted_length} chars)`, 
            'success'
        );
    });
    
    socket.on('message_status', function(data) {
        const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
        if (messageElement && messageElement._statusElement) {
            updateMessageStatus(messageElement._statusElement, data.status);
            
            if (data.status === 'delivered') {
                addEncryptionLog(`✓ Message delivered to ${data.recipient}`, 'success');
            }
        }
    });
    // Handle incoming text messages
    socket.on('new_message', function(data) {
        console.log('New message received:', data);
        
        // Check if we already have this message to avoid duplicates
        if (data.message_id && document.querySelector(`[data-message-id="${data.message_id}"]`)) {
            return;
        }
        
        const isSent = data.sender === currentUser;
        const isAIPrompt = data.is_ai_prompt || false;
        const isPlaintext = data.is_plaintext || false;
        
        const messageElement = addMessageToUI(
            data.sender,
            data.content || data.encrypted_content,
            isSent ? 'sent' : 'received',
            data.timestamp || new Date().toISOString(),
            isPlaintext,  // Use plaintext flag
            data.message_id,
            data.delivered ? 'delivered' : 'sent',
            data.is_file || false,
            false, // isAI
            isAIPrompt // isAIPrompt
        );
        
        if (!messageElement) return;
        
        // If this is an incoming message and not plaintext, try to decrypt it
        if (!isSent && !isPlaintext) {
            decryptMessage(messageElement, data.encrypted_content, data.message_id);
        }
        
        // Update message status if it's our message
        if (isSent && data.delivered) {
            const statusElement = messageElement.querySelector('.message-status');
            if (statusElement) {
                updateMessageStatus(statusElement, 'delivered');
            }
        }
        
        scrollToBottom();
    });
    
    // Handle incoming file messages
    socket.on('new_file_message', function(data) {
        console.log('New file message received:', data);
        
        // Check if we already have this message to avoid duplicates
        if (data.message_id && document.querySelector(`[data-message-id="${data.message_id}"]`)) {
            return;
        }
        
        const isSent = data.sender === currentUser;
        const fileInfo = data.file_info;
        const fileLink = `<a href="${fileInfo.download_url}" target="_blank" class="text-primary">${fileInfo.filename}</a>`;
        
        // Add message to UI
        addMessageToUI(
            data.sender,
            `📎 ${fileLink} (${formatFileSize(fileInfo.size)})`,
            isSent ? 'sent' : 'received',
            data.timestamp || new Date().toISOString(),
            true,  // isPlaintext
            data.message_id,
            'delivered',
            true   // isFile
        );
        
        scrollToBottom();
    });
    

    
    // Handle decryption errors
    socket.on('decryption_error', function(data) {
        const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
        if (messageElement) {
            const contentDiv = messageElement.querySelector('.message-text');
            if (contentDiv) {
                contentDiv.innerHTML = 'Failed to decrypt message. <a href="#" class="retry-decrypt" data-message-id="' + data.message_id + '">Retry</a>';
                contentDiv.style.cursor = 'pointer';
                
                // Add retry handler
                const retryLink = contentDiv.querySelector('.retry-decrypt');
                if (retryLink) {
                    retryLink.onclick = (e) => {
                        e.preventDefault();
                        const encryptedContent = messageElement.dataset.encryptedContent;
                        if (encryptedContent) {
                            decryptMessage(messageElement, encryptedContent, data.message_id);
                        }
                    };
                }
            }
        }
        
        addEncryptionLog('❌ Decryption error: ' + (data.message || 'Unknown error'), 'danger');
        console.error('Decryption error:', data);
    });
    
    socket.on('message_decrypted', function(data) {
        // Find the message element and update it
        const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
        if (messageElement) {
            // Clear any pending timeout
            if (messageElement._decryptTimeout) {
                clearTimeout(messageElement._decryptTimeout);
                delete messageElement._decryptTimeout;
            }
            
            const contentDiv = messageElement.querySelector('.message-text');
            if (contentDiv) {
                const plain = data.content || 'Could not decrypt message';
                const codeMatch = plain.trim().match(/^@\.(\w+)\s([\s\S]*)/);
                if (codeMatch) {
                    const ext = codeMatch[1];
                    const codeBody = codeMatch[2];
                    contentDiv.innerHTML = '';
                    const header = document.createElement('div');
                    header.className = 'd-flex justify-content-between align-items-center bg-light border-bottom px-2 py-1 code-header';
                    header.innerHTML = `<strong>.${ext}</strong><div><button type="button" class="btn btn-sm btn-link copy-code"><i class="fas fa-copy"></i></button><a href="#" class="btn btn-sm btn-link download-code" role="button"><i class="fas fa-download"></i></a></div>`;
                    const pre = document.createElement('pre');
                    pre.className = 'm-0 p-2';
                    const codeEl = document.createElement('code');
                    codeEl.textContent = codeBody;
                    pre.appendChild(codeEl);
                    contentDiv.appendChild(header);
                    contentDiv.appendChild(pre);
                    header.querySelector('.copy-code').addEventListener('click', (e)=>{e.stopPropagation(); navigator.clipboard.writeText(codeBody);});
                    header.querySelector('.download-code').onclick = (e)=>{const blob=new Blob([codeBody],{type:'text/plain'});e.currentTarget.href=URL.createObjectURL(blob);e.currentTarget.download=`snippet.${ext}`;};
                } else {
                    contentDiv.textContent = plain;
                }
                contentDiv.style.cursor = 'default';
                
                // If decryption failed, add a retry button
                if (!data.content) {
                    const retryBtn = document.createElement('button');
                    retryBtn.className = 'btn btn-sm btn-outline-secondary ms-2';
                    retryBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Retry';
                    retryBtn.onclick = () => {
                        const encryptedContent = messageElement.dataset.encryptedContent;
                        if (encryptedContent) {
                            decryptMessage(messageElement, encryptedContent, data.message_id);
                        }
                    };
                    contentDiv.appendChild(retryBtn);
                }
            }
        }
    });
    
    socket.on('error', function(data) {
        addEncryptionLog('❌ Error: ' + (data.message || 'Unknown error'), 'danger');
        console.error('Socket error:', data);
    });
    
    // AI Message Handlers
    socket.on('ai_request_received', function(data) {
        addEncryptionLog('🤖 AI request received: ' + data.prompt.substring(0, 50) + '...', 'info');
        // Note: Don't add the AI request to UI here - it's already handled by regular message flow
    });
    
    socket.on('ai_typing', function(data) {
        // Show typing indicator for AI
        showAITyping();
    });
    
    socket.on('ai_response', function(data) {
        hideAITyping();
        addEncryptionLog('🤖 AI response received', 'success');
        
        // Add AI response to chat
        addMessageToUI(
            'SecureAI',
            data.content,
            'received',
            data.timestamp,
            true,
            data.message_id,
            'delivered',
            false,
            true  // isAI flag
        );
    });
    
    socket.on('ai_error', function(data) {
        hideAITyping();
        addEncryptionLog('❌ AI Error: ' + data.error, 'danger');
        
        // Add error message to chat
        addMessageToUI(
            'SecureAI',
            '🚨 Sorry, I encountered an error: ' + data.error,
            'received',
            new Date().toISOString(),
            true,
            'ai-error-' + Date.now(),
            'delivered',
            false,
            true  // isAI flag
        );
    });
    
    // Handle connection events
    socket.on('connect', function() {
        addEncryptionLog('🔌 Connected to secure server', 'success');
        // Join the chat room for this user
        socket.emit('join', {username: currentUser});
    });
    
    socket.on('disconnect', function() {
        addEncryptionLog('🔌 Disconnected from server', 'warning');
    });
    
    // Handle online users events
    socket.on('online_users', function(data) {
        console.log('Online users received:', data);
        if (data && data.users) {
            updateSidebarOnlineUsers(data.users);
        }
    });
    
    socket.on('user_status', function(data) {
        console.log('User status change:', data);
        if (data.username && data.username !== currentUser) {
            if (data.status === 'online') {
                sidebarOnlineUsers.add(data.username);
            } else if (data.status === 'offline') {
                sidebarOnlineUsers.delete(data.username);
            }
            displaySidebarOnlineUsers();
        }
    });

    // Toggle keys visibility
    const toggleKeysBtn = document.getElementById('toggle-keys-btn');
    const encryptionKeysSection = document.getElementById('encryption-keys');
    const showPrivateKeyCheckbox = document.getElementById('show-private-key');
    const privateKeyTextarea = document.getElementById('private-key');
    const validateBtn = document.getElementById('validate-encryption-btn');
    const validationResults = document.getElementById('validation-results');
    const validationStatus = document.getElementById('validation-status');
    const validationMessage = document.getElementById('validation-message');
    
    // Toggle keys section
    toggleKeysBtn?.addEventListener('click', async () => {
        const isHidden = encryptionKeysSection.classList.toggle('d-none');
        
        if (!isHidden && !encryptionKeysSection.dataset.loaded) {
            try {
                // Show loading state
                toggleKeysBtn.disabled = true;
                toggleKeysBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading keys...';
                
                // Fetch keys from server
                const response = await fetch('/api/keys');
                const data = await response.json();
                
                if (data.success) {
                    // Display public key
                    document.getElementById('public-key').value = data.public_key;
                    
                    // Display private key (initially hidden)
                    privateKeyTextarea.value = data.private_key;
                    
                    // Mark as loaded
                    encryptionKeysSection.dataset.loaded = 'true';
                    
                    // Update button text
                    toggleKeysBtn.innerHTML = '<i class="fas fa-key"></i> Hide My Keys';
                    
                    // Add encryption log
                    addEncryptionLog('🔑 Encryption keys loaded', 'success');
                } else {
                    throw new Error(data.message || 'Failed to load keys');
                }
            } catch (error) {
                console.error('Error loading keys:', error);
                addEncryptionLog('❌ Failed to load encryption keys', 'danger');
                // Hide the keys section on error
                encryptionKeysSection.classList.add('d-none');
            } finally {
                toggleKeysBtn.disabled = false;
                if (encryptionKeysSection.classList.contains('d-none')) {
                    toggleKeysBtn.innerHTML = '<i class="fas fa-key"></i> Show My Keys';
                }
            }
        } else {
            // Toggle button text
            toggleKeysBtn.innerHTML = isHidden ? 
                '<i class="fas fa-key"></i> Show My Keys' : 
                '<i class="fas fa-key"></i> Hide My Keys';
        }
    });
    
    // Toggle private key visibility
    showPrivateKeyCheckbox?.addEventListener('change', (e) => {
        privateKeyTextarea.type = e.target.checked ? 'text' : 'password';
    });
    
    // Handle encryption validation
    validateBtn?.addEventListener('click', async () => {
        if (!validateBtn.classList.contains('disabled')) {
            try {
                // Show loading state
                validateBtn.classList.add('disabled');
                validateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
                
                // Show validation section
                validationResults.classList.remove('d-none');
                validationStatus.textContent = 'Testing...';
                validationStatus.className = 'badge bg-secondary';
                
                // Generate a random test message
                const testMessage = `Test message ${Math.random().toString(36).substring(2, 8)}`;
                
                // Call the validation endpoint
                const response = await fetch('/api/validate-encryption', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        recipient: '{{ recipient }}',
                        message: testMessage
                    })
                });
                
                const data = await response.json();
                
                // Update UI with results
                document.getElementById('test-original').textContent = data.original_message || testMessage;
                document.getElementById('test-encrypted').textContent = data.encrypted_message || 'Error';
                document.getElementById('test-decrypted').textContent = data.decrypted_message || 'Error';
                
                if (data.success && data.validation_passed) {
                    validationStatus.textContent = 'Success';
                    validationStatus.className = 'badge bg-success';
                    validationMessage.innerHTML = `
                        <div class="alert alert-success p-2 mb-0">
                            <i class="fas fa-check-circle me-1"></i>
                            Message successfully encrypted with {{ recipient }}'s public key and decrypted with their private key.
                        </div>`;
                    addEncryptionLog('✅ Encryption test passed successfully', 'success');
                } else {
                    validationStatus.textContent = 'Failed';
                    validationStatus.className = 'badge bg-danger';
                    validationMessage.innerHTML = `
                        <div class="alert alert-danger p-2 mb-0">
                            <i class="fas fa-exclamation-triangle me-1"></i>
                            ${data.message || 'Encryption validation failed. The message could not be decrypted correctly.'}
                        </div>`;
                    addEncryptionLog('❌ Encryption test failed: ' + (data.message || 'Unknown error'), 'danger');
                }
                
            } catch (error) {
                console.error('Validation error:', error);
                validationStatus.textContent = 'Error';
                validationStatus.className = 'badge bg-danger';
                validationMessage.innerHTML = `
                    <div class="alert alert-danger p-2 mb-0">
                        <i class="fas fa-exclamation-triangle me-1"></i>
                        An error occurred during validation. Please check the console for details.
                    </div>`;
                addEncryptionLog('❌ Error during encryption test', 'danger');
            } finally {
                // Reset button state
                validateBtn.classList.remove('disabled');
                validateBtn.innerHTML = '<i class="fas fa-check-circle"></i> Validate';
                
                // Scroll to show results
                validationResults.scrollIntoView({ behavior: 'smooth' });
            }
        }
    });
    
    // Copy to clipboard functionality
    document.querySelectorAll('.copy-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const targetId = btn.getAttribute('data-target');
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
                // Select the text
                targetElement.select();
                
                try {
                    // Copy to clipboard
                    document.execCommand('copy');
                    
                    // Show feedback
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-check"></i>';
                    btn.classList.add('text-success');
                    
                    // Reset after 2 seconds
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.classList.remove('text-success');
                    }, 2000);
                    
                    // Add log
                    addEncryptionLog(`📋 ${targetId === 'public-key' ? 'Public' : 'Private'} key copied to clipboard`, 'info');
                } catch (err) {
                    console.error('Failed to copy text:', err);
                    addEncryptionLog('❌ Failed to copy to clipboard', 'danger');
                }
            }
        });
    });
</script>
{% endblock %}
